"""RuNNer"""

from .dataset import DataSet, Sample, AtomicData, CollectiveData
from .unit import UnitConversion
from .utils import get_time_and_date
import random
import numpy as np

# ----------------------------------------------------------------------------
# Setup class for RuNNer adaptor
# ----------------------------------------------------------------------------
class RunnerAdaptor:
    """A bas class for conversion file formats of RuNNer package."""

    def __init__(self):
        self.dataset = DataSet()  # initialize with empty RuNNer data set

    def clean(self):
        self.dataset = DataSet()

    def write_runner(self, filename, uc=UnitConversion()):
        """This method writes outputs in RuNNer structure file format."""
        with open(str(filename), "w") as out_file:
            # loop over samples
            for sample in self.dataset.samples:
                # add begin and comment
                out_file.write("begin\n")
                out_file.write("comment Generated by PyNNP at %s\n" % get_time_and_date())
                # write cell data (collective data)
                cell = [c for c in sample.collective.cell]
                for i in range(0, 9, 3):
                    out_file.write("lattice %.10f %.10f %.10f\n" % tuple([c*uc.length for c in cell[i:i+3]]))
                # loop over atoms in a sample (atomic data)
                for atom in sample.atomic:
                    out_file.write("atom ")
                    out_file.write("%15.10f %15.10f %15.10f " % tuple([pos*uc.length for pos in atom.position]))
                    out_file.write("%s %15.10f %15.10f " % (atom.symbol, atom.charge*uc.charge, atom.energy*uc.energy*0.0))
                    out_file.write("%15.10f %15.10f %15.10f\n" % tuple([frc*uc.force for frc in atom.force]))
                # write total energy and charge (collective data)
                out_file.write("energy %.10f\n" % (sample.collective.total_energy*uc.energy))
                out_file.write("charge %.10f\n" % (sample.collective.total_charge*uc.charge))
                out_file.write("end\n")
        # return object
        return self

    def read_runner(self, filename="input.data", uc=UnitConversion()):
        """This method reads the RuNNer atomic structure file format."""
        in_file = open(str(filename), "r")
        line = in_file.readline()
        # loop over lines in the input file
        while line:
            # read a frame
            if "begin" in line.rstrip("/n").split()[0]:
                # initialize sample data
                sample = Sample()
                cell = []
                atomid = 0
                total_energy = 0.0
                total_charge = 0.0
                # loop over current data frame
                while True:
                    # read next line
                    line = next(in_file).rstrip("/n").split()
                    # skip comment line
                    if "comment" in line[0]:
                        continue
                    # read cell data
                    if "lattice" in line[0]:
                        for c in line[1:4]:
                            cell.append(float(c)*uc.length)
                    # read atomic data
                    if "atom" in line[0]:
                        atomid += 1
                        position = [float(pos)*uc.length for pos in line[1:4]]
                        symbol = line[4]
                        charge = float(line[5])*uc.charge
                        energy = float(line[6])*uc.energy
                        force = [float(frc)*uc.force for frc in line[7:10]]
                        sample.atomic.append(AtomicData(atomid, position, symbol, charge, energy, force))
                    # read total energy (collective data)
                    if "energy" in line[0]:
                        total_energy = float(line[1])*uc.energy
                    # read total charge (collective data)
                    if "charge" in line[0]:
                        total_charge = float(line[1])*uc.charge
                    # end of current data frame
                    if "end" in line[0]:
                        break
                # set collective data
                assert len(cell) == 9, "Unexpected number of cell dimension (%d)" % len(cell)
                sample.collective = CollectiveData(cell, total_energy, total_charge)
                # add sample to the data set
                self.dataset.append(sample)
            # next line
            line = in_file.readline()
        # return object
        return self

    def sample(self, number_of_samples=None, seed=1234):
        """This method randomly samples and replaces the data set."""
        # set random seed
        random.seed(int(seed))
        # set number of samples
        if number_of_samples is None:
            number_of_samples = 1  # default number of samples (one)
        else:
            assert int(number_of_samples) <= self.dataset.number_of_samples, "Unexpected number of samples"
        # shuffle list of indices
        random.shuffle(self.dataset.samples)
        # replace the data set with the randomly but uniquely selected samples
        self.dataset.samples = self.dataset.samples[:int(number_of_samples)]
        # return object
        return self

    def select(self, list_of_indices):
        """This method selects and replace the data set based on given indices (zero-index-based)."""
        if isinstance(list_of_indices, int):
            list_of_indices = [list_of_indices]
        self.dataset.samples = [self.dataset.samples[int(index)] for index in list(list_of_indices)]
        return self

    def delete(self, list_of_indices):
        """This method deletes some samples from data set based on given indices (zero-index-based)."""
        if isinstance(list_of_indices, int):
            list_of_indices = [list_of_indices]
        n_samples = self.dataset.number_of_samples
        self.dataset.samples = [self.dataset.samples[index] for index in range(n_samples) if index not in list(list_of_indices)]
        return self

    def get_energies(self):
        """This methods return a list of total energies of samples normalized to number of atoms."""
        energies = [sample.collective.total_energy / sample.number_of_atoms for sample in self.dataset.samples]
        return np.array(energies)

    @property
    def energies(self):
        """This methods return a list of total energies of samples normalized to number of atoms."""
        return self.get_energies()

    def get_range_of_energy(self):
        """This method returns the difference between max and min of the total energy among
        samples normalized to the number of atoms."""
        energies = self.get_energies()
        return np.max(energies)-np.min(energies)

    @property
    def range_of_energy(self):
        """This method returns the difference between max and min of the total energy among
        samples nomalzied to the number of atoms."""
        return self.get_range_of_energy()

    def get_forces(self, list_of_indices=None, components=(0, 1, 2)):
        """This method returns a list of forces for a given list of indices (zero-based)
        of samples (default is all samples)."""
        # check input list of indices
        if list_of_indices is None:
            samples = self.dataset.samples
        elif isinstance(list_of_indices, int):
            samples = [self.dataset.samples[list_of_indices]]
        else:
            samples = [self.dataset.samples[index] for index in list(list_of_indices)]
        # check input components
        if isinstance(components, int):
            components = [components]
        else:
            components = list(components)
        # list of forces
        forces = []
        for sample in samples:
            for atom in sample.atomic:
                forces.append([atom.force[i] for i in components])
        # return the list of force components for the given samples
        return np.array(forces)

    @property
    def forces(self):
        """This method returns a list of forces for all the samples and components."""
        return self.get_forces()

    def get_range_of_force(self, components=(0, 1, 2)):
        """This method returns the difference between max and min of the force components among
        atoms and samples."""
        forces = self.get_forces(components)
        return np.max(forces) - np.min(forces)

    @property
    def range_of_force(self):
        """This method returns the difference between max and min of the force components among
        atoms and samples."""
        return self.get_range_of_force()

    def get_number_of_samples(self):
        return self.dataset.get_number_of_samples()

    @property
    def number_of_samples(self):
        return self.get_number_of_samples()

    def calculate_energy_errors(self, obj):
        """This method returns a list of absolute-errors of the total energy for samples
        (normalized to the number of atoms)."""
        assert isinstance(obj, RunnerAdaptor), "Unexpected object type"
        assert self.number_of_samples == obj.number_of_samples, "Unequal number of samples"
        for i in range(self.number_of_samples):
            assert self.dataset.samples[i].number_of_atoms == obj.dataset.samples[i].number_of_atoms, "Unequal number of atoms"
        return np.abs(self.get_energies()-obj.get_energies())

    def calculate_force_errors(self, obj, method="max", components=(0, 1, 2)):
        """This method returns a list of absolute-max-errors of the atomic forces for samples."""
        assert isinstance(obj, RunnerAdaptor), "Unexpected input object type"
        assert self.number_of_samples == obj.number_of_samples, "Unequal number of samples"
        force_errors = []
        for i in range(self.number_of_samples):
            # check number of atoms in each corresponding sample
            assert self.dataset.samples[i].number_of_atoms == obj.dataset.samples[i].number_of_atoms, "Unequal number of atoms"
            # apply method for error calculation
            if method.lower() == "max":
                error = np.max(np.abs(self.get_forces(i,components) - obj.get_forces(i, components)))
            elif method.lower() == "rmse":
                error = np.sqrt(np.mean((self.get_forces(i, components) - obj.get_forces(i, components))**2))
            else:
                raise AssertionError("Unknown input method for force-error calculation")
            # add calculated error for each sample
            force_errors.append(error)
        # return a list of errors
        return np.array(force_errors)

    def find(self, obj, energy_error_threshold=None, force_error_threshold=None, method="max", components=(0, 1, 2)):
        """This method returns a list of sample indices (zero-based) with energy/force error
        beyond the specified thresholds."""
        # energy
        energy_index = []
        if energy_error_threshold is not None:
            energy_errors = self.calculate_energy_errors(obj)
            for i in range(0, self.number_of_samples):
                if energy_errors[i] >= energy_error_threshold:
                    energy_index.append(i)
        # force
        force_index = []
        if force_error_threshold is not None:
            force_errors = self.calculate_force_errors(obj, method, components)
            for i in range(0, self.number_of_samples):
                if force_errors[i] >= force_error_threshold:
                    force_index.append(i)
        # return an list of unique indices.
        return list(set(energy_index+force_index))

    def calculate_min_distances(self):
        """This method returns a list of absolute-errors of the total energy for samples
        (normalized to the number of atoms)."""
        list_of_min_distances = []
        for sample in self.dataset.samples:
            r2min = 1E6
            for i in range(sample.number_of_atoms):
                atom_i = sample.atomic[i]
                for j in range(sample.number_of_atoms):
                    if i >= j:
                        continue
                    atom_j = sample.atomic[j]
                    r2 = sample.distance2(atom_i, atom_j)
                    if r2 < r2min:
                        r2min = r2
            list_of_min_distances.append(np.sqrt(r2min))
        return np.array(list_of_min_distances)

    def write_xyz(self, filename, uc=UnitConversion()):
        """This method writes outputs in .xyz structure file format."""
        with open(str(filename), "w") as out_file:
            # loop over samples
            for sample in self.dataset.samples:
                # add begin and comment
                out_file.write("%d\n"%sample.number_of_atoms)
                out_file.write("Generated by PyNNP at %s\n" % get_time_and_date())
                # write cell data (collective data)
                # out_file("lattice ")
                # cell = [c for c in sample.collective.cell]
                # for i in range(0, 9, 3):
                #     out_file.write("%.10f %.10f %.10f " % tuple([c*uc.length for c in cell[i:i+3]]))
                # out_file.write("\n")
                # loop over atoms in a sample (atomic data)
                for atom in sample.atomic:
                    out_file.write("%8s " % atom.symbol)
                    out_file.write("%15.10f %15.10f %15.10f\n" % tuple([pos*uc.length for pos in atom.position]))
        # return object
        return self